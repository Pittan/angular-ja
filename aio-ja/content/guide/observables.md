# オブザーバブル

オブザーバブルは、アプリケーションの中でパブリッシャー(発行者)とサブスクライバー(購読者)間でメッセージを渡すためのサポートを提供します。オブザーバブルは、イベント処理、非同期プログラミング、および複数の値の処理のための他のテクニックよりも大きな利点を提供します。

オブザーバブルは宣言的です&mdash;つまり、値を公開するための関数を定義しますが、コンシューマー(消費者)がそれをサブスクライブ(購読)するまでは実行されません。サブスクライブするコンシューマーは、機能が完了するまで、またはアンサブスクライブ(購読を解除)するまで通知を受け取ります。

オブザーバブルは、コンテキストに応じて、リテラル、メッセージ、またはイベントのいずれかのタイプの複数の値を提供できます。受け取るためのAPIは値が同期的・非同期的に提供される場合も同じです。基本的なセットアップとティアダウン（取り壊し）はオブザーバブルにとって処理されるので、あなたのアプリケーションコードは値を消費するためにサブスクライブを行うことと、それが済んだらアンサブスクライブすることだけを心配する必要があります。ストリームがキー入力、HTTPレスポンス、インターバルタイマーのどれでも、値をリスニングしたり、リスニングを止めるためのインターフェイスは同じです。

これらの利点のために、ObservableはAngular内で広く使用されており、アプリの開発にも推奨されています。

## 基本的な使用法と用語

パブリッシャーとして、*subscriber* 関数を定義する `Observable` インスタンスを作成することができます。これは、コンシューマーが `subscribe（）`メソッドを呼び出したときに実行される関数です。サブスクライバー関数はどのように値を入手・生成したりメッセージがパブリッシュされるかを定義します。

作成したオブザーバブルを実行して値を受信するには、*observer* を渡す `subscribe()` メソッドを呼ぶ必要があります。これは、受け取った通知のハンドラーを定義するJavaScriptオブジェクトです。`subscribe()` は 通知を受信を止めるための `unsubscribe()` メソッドがある `Subscription` オブジェクトを返します。

ここでは、オブザーバブルを使用してジオロケーションの更新を提供する方法を示すことによって、基本的な使用モデルの例を示します。

<code-example path="observables/src/geolocation.ts" title="ジオロケーションのアップデートをオブザーブする"></code-example>

## オブザーバーを定義する


オブザーバブルの通知を受け取るハンドラーは、`Observer` インタフェースを実装します。これは、オブザーバブルが送信できる3種類の通知を処理するためのコールバックメソッドを定義するオブジェクトです。

| 通知の種類 | 説明 |
|:---------|:-------------------------------------------|
| `next`  | 必須です。それぞれの値が提供されたときのハンドラーです。実行が開始されてから0回以上呼び出されます。|
| `error` | オプションです。エラー通知のハンドラーです。エラーはオブザーバブルインスタンスの実行を停止します。|
| `complete` | オプションです。実行完了通知のハンドラーです。遅延した値は、実行完了後もnextハンドラーに引き続き渡されます。|

オブザーバーオブジェクトは、これらのハンドラーの任意の組み合わせを定義することができます。いずれかの通知タイプのハンドラを指定しなかった場合、オブザーバはそのタイプの通知を無視します。

## サブスクライブ

`Observable` インスタンスは他の誰かがサブスクライブすると値をパブリッシュしはじめます。サブスクライブするためにはインスタンスの `subscribe()` メソッドを呼び出し、オブザーバーオブジェクトを渡して通知を受け取ります。

<div class="l-sub-section">
   サブスクリプションがどのように動作するかを示すために、新しいオブザーバブルを作成する必要があります。
   新しいインスタンスを作成するために使用するコンストラクタがありますが、例として頻繁に使用される型の単純なオブザーバブルを作成する `Observable`クラスでいくつかの静的メソッドを使用できます。

  * `Observable.of(...items)`&mdash;引数として提供された値を同期的に提供する`Observable`インスタンスを返します。
  * `Observable.from(iterable)`&mdash;引数を`Observable`インスタンスに変換します。このメソッドは、通常、配列をobservableに変換するために使用されます。

</div>

受信したメッセージをコンソールに記録するオブザーバーを使って、シンプルなオブザーバブルを作成してサブスクライブする例を次に示します。

<code-example
  path="observables/src/subscribing.ts"
  region="observer"
  title="Subscribe using observer"></code-example>

あるいは、`subscribe()`メソッドは、コールバック関数定義を`next`、`error`、`complete`ハンドラーのために、行内で受け入れることができます。例えば、次の`subscribe()`コールは、定義済みのオブザーバーを指定するコールと同じです。

<code-example path="observables/src/subscribing.ts" region="sub_fn" title="Subscribe with positional arguments"></code-example>

いずれの場合も、`next`ハンドラーは必須です。`error`と`complete`ハンドラーはオプションです。

`next()`関数はコンテキストに応じて、例えば、メッセージ文字列、イベントオブジェクト、数値、または構造体を受け取ることができることに注意してください。一般的な用語として、私達はオブザーバブルによって公開されたデータを*ストリーム*と呼びます。任意のタイプの値はオブザーバブルで表現でき、値はストリームとしてパブリッシュされます。

## オブザーバブルを作成する

`Observable` コンストラクターを使用して任意のタイプのオブザーバブルストリームを作成してください。コンストラクターは、オブザーバブルの`subscribe()`メソッドが実行されたときに実行するサブスクライバー関数を引数としてとります。サブスクライバー関数は`Observer`オブジェクトを受け取り、オブザーバの` next()`メソッドに値を公開することができます。

例えば、上の`Observable.of(1,2,3)`に相当するオブザーバブルを作成するには、次のようにします：

<code-example path="observables/src/creating.ts" region="subscriber" title="Create observable with constructor"></code-example>

この例を少しステップアップすると、イベントを公開するオブザーバブルを作成できます。この例では、サブスクライバー関数はインラインで定義されています。

<code-example path="observables/src/creating.ts" region="fromevent" title="Create with custom fromEvent function"></code-example>

Now you can use this function to create an observable that publishes keydown events:

<code-example path="observables/src/creating.ts" region="fromevent_use" title="Use custom fromEvent function"></code-example>

## マルチキャスト

典型的なオブザーバブルは、サブスクライブしたオブザーバーごとに独立した新しい実行を作成します。オブザーバーがサブスクライブすると、オブザーバブルはイベントハンドラをつなぎ、そのオブザーバーに値を渡します。2つ目のオブザーバーが加入すると、オブザーバブルは新しいイベントハンドラをつなぎ、別の実行でその2つ目のオブザーバに値を渡します。

場合によっては、各サブスクライバーに対して独立した実行を開始するのではなく、値が既に送出されていても、各サブスクリプションが同じ値を取得するようにしたいことがあるでしょう。これは、ドキュメントオブジェクトのクリックが観測されるような場合に当てはまります。

*マルチキャスト* は、1回の実行で複数のサブスクライバーにブロードキャストする方法です。マルチキャストをするオブザーバブルの場合、、ドキュメントに複数のリスナーを登録するのではなく、最初のリスナーを再利用して値を各サブスクライバーに送信します。

オブザーバブルを作成するときは、そのオブザーバブルをどのように使用するか、およびその値をマルチキャストするかどうかを決定する必要があります。

それぞれの数値が送出されてから1秒遅れて、1から3までカウントする例を見てみましょう。

<code-example path="observables/src/multicasting.ts" region="delay_sequence" title="Create a delayed sequence"></code-example>

2回サブスクライブすると、2つの別々のストリームがあり、それぞれが毎秒値を送出することに注意してください。これは次のようになります。

<code-example path="observables/src/multicasting.ts" region="subscribe_twice" title="Two subscriptions"></code-example>

 オブサーバブルをマルチキャストするように書き換えると次のようになります。

<code-example path="observables/src/multicasting.ts" region="multicast_sequence" title="Create a multicast subscriber"></code-example>

<div class="l-sub-section">
  オブザーバブルをマルチキャストするには少しだけ多くのセットアップがかかりますが、特定のアプリケーションで役立ちます。後で、マルチキャスティングのプロセスを簡略化して、どんなオブザーバブルでもマルチキャストできるようになるツールを見ていきます。
</div>

## Error handling

オブザーバブルは値を非同期的に生成するため、try/catchは効果的にエラーを捕捉しません。代わりに、オブザーバに`error`コールバックを指定することでエラーを処理します。 また、エラーを生成すると、オブザーバブルはサブスクリプションをクリーンアップし、値の生成を停止します。オブザーバブルは値を生成する（`next`コールバックを呼び出す)か、`complete`または` error`コールバックを呼び出すこと完了することができます。

<code-example>
myObservable.subscribe({
  next(num) { console.log('Next num: ' + num)},
  error(err) { console.log('Received an errror: ' + err)}
});
</code-example>

エラー処理（特にエラーからの回復）については後のセクションで詳しく説明します。